#include <Arduino.h>

// --- HARDWARE DRIVER INTEGRATION (TFT_eSPI Example) ---
#include <TFT_eSPI.h> 
#include <lvgl.h>
#include <Wire.h>
#include <RTClib.h>
// Include necessary headers for heap allocation
#include "esp_heap_caps.h" 
#include <DHT.h>

// --- DHT CONFIG ---
#define DHT_PIN 27         // change this to the GPIO you actually use
#define DHT_TYPE DHT11     // DHT11
#define LDR_PIN 14   // ADC pin you're using
#define buzzerPin 12
DHT dht(DHT_PIN, DHT_TYPE);

// reading interval
const unsigned long Sensor_Read_Interval = 5000UL;
static unsigned long lastSensorMs = 0;


int ldrRaw = 0;      // raw value
int ldrPercent = 0;  // 0–100% scaled value

// tune these two based on your real readings:
const int LDR_MIN = 0;   // darkest reading
const int LDR_MAX = 3500;  // brightest reading


// ---------- MQ135 integration (drop into your existing sensor code) ----------
#define MQ_PIN        34        // change to your MQ135 ADC pin
#define MQ_ADC_MAX    4095      // ESP32 12-bit ADC default; change to 1023 for 10-bit boards
#define MQ_RAW_MIN    0         // raw value corresponding to "clean" (calibrate later)
#define MQ_RAW_MAX    3000      // raw value that you treat as very bad (calibrate)

// optional smoothing (exponential moving average) to reduce jitter
#define MQ_SMOOTHING_ENABLED 1
#define MQ_ALPHA 0.2f           // 0..1 (higher = more responsive, lower = smoother)
static float mq_ema = -1.0f;    // holds EMA state

RTC_DS3231 rtc;

int hour, minute, date, month, dow;
// Month names (short) — safe to pass to set_var_month()
static const char *month_names[] = {
  "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
};

// --- Relay pin configuration ---
#define RELAY_LIGHT_PIN 15  // physical pin for light relay (D15)
#define RELAY_FAN_PIN    35  // physical pin for fan relay (D4)
// Set true if relays are active-low (most common). Set false if active-high.
#define RELAY_ACTIVE_LOW false

static inline void relay_hw_write(uint8_t pin, bool on) {
  if (RELAY_ACTIVE_LOW) digitalWrite(pin, on ? LOW : HIGH);
  else                  digitalWrite(pin, on ? HIGH : LOW);
}

#ifdef __cplusplus
extern "C" {
#endif

void relay_light_set(bool on) {
  relay_hw_write(RELAY_LIGHT_PIN, on);
}

void relay_fan_set(bool on) {
  relay_hw_write(RELAY_FAN_PIN, on);
}

#ifdef __cplusplus
}
#endif




// Create a TFF_eSPI object. The configuration must be done in the
// User_Setup.h file inside the TFT_eSPI library folder.
TFT_eSPI tft = TFT_eSPI();

// Calibration constants (fixed — no rotation)
const uint16_t RAW_MIN_X = 429;
const uint16_t RAW_MAX_X = 3593;
const uint16_t RAW_MIN_Y = 1905;
const uint16_t RAW_MAX_Y = 3345;

// Settings for your hardware (you said no rotation)
const bool SWAP_AXES = false;
const bool INVERT_X  = false;
const bool INVERT_Y  = true;

// --- EEZ STUDIO GENERATED FILES INCLUSION ---
// Assuming these files are available in the project structure
#include "ui.h"
#include "screens.h" // Contains the 'objects_t' struct and 'extern objects_t objects;'
#include "vars.h"   // <- declares get_var_* / set_var_* functions generated by EEZ Studio

// --- Configuration Constants (FIXED RESOLUTION FOR COMPILE TIME) ---
#define LV_HOR_RES_MAX 320 
#define LV_VER_RES_MAX 240 
// Buffer size remains 1/5th.
#define DISP_BUF_SIZE (LV_HOR_RES_MAX * LV_VER_RES_MAX / 5) 

// --- LVGL Display and Input Variables ---
lv_color_t *buf_1; 
lv_display_t *disp;

// Flag to manually control color swapping
#define FORCE_COLOR_SWAP 1 


// ------------------------------------------------------------------
// DO NOT rename these — update them in your sensor routines (DHT, MQ135, LDR, RTC)
float sensorTemperature = 32;             // Celsius (e.g. 25.3)
float sensorHumidity    = 85;             // Percent (e.g. 53.4)
int   airQualityRaw     = 0;              // Raw MQ135 reading or AQI-like int
String airQualityStatusStr = "Good";   // "Good", "Super", "Poor", "Toxic", etc.
int   ldrReading        = 44;              // Raw LDR ADC value (or computed lux)
//char  dateStr[32]      = "";               // human-readable date (e.g. "2025-11-30")
//char  dayOfWeekStr[16] = "";               // e.g. "Sun", "Monday"
// Forward prototype so setup() can reference it even if function is below
void disp_flush(lv_display_t *display, const lv_area_t *area, unsigned char *data);

// ------------------------------------------------------------------
// Small inline mapper (safe vs inverted raw ranges)
// ------------------------------------------------------------------
static inline int32_t fmap_clamped(int32_t val, int32_t in_min, int32_t in_max,
                                   int32_t out_min, int32_t out_max) {
    if (in_max == in_min) return out_min;
    if (in_min < in_max) {
        long mapped = (long)(val - in_min) * (out_max - out_min) / (long)(in_max - in_min) + out_min;
        if (mapped < out_min) return out_min;
        if (mapped > out_max) return out_max;
        return (int32_t)mapped;
    } else {
        long mapped = (long)(in_min - val) * (out_max - out_min) / (long)(in_min - in_max) + out_min;
        if (mapped < out_min) return out_min;
        if (mapped > out_max) return out_max;
        return (int32_t)mapped;
    }
}


// --- 2. Input Read Callback (Reads touch input from the physical screen) ---

/**
 * @brief Reads touch input and reports the state (pressed/released) and coordinates to LVGL.
 */

void touch_read(lv_indev_t *indev_driver, lv_indev_data_t *data) {
    uint16_t tx = 0, ty = 0;
    bool pressed = tft.getTouch(&tx, &ty);

    const uint16_t sw = tft.width();   // 320
    const uint16_t sh = tft.height();  // 240

    if (!pressed) {
        data->state = LV_INDEV_STATE_RELEASED;
        return;
    }

    data->state = LV_INDEV_STATE_PRESSED;

    // Detect whether library already scales coordinates (0..screen)
    bool scaled = (tx <= sw && ty <= sh);

    int32_t mx, my;

    if (scaled) {
        // Already in screen coords — apply swap/invert if needed
        mx = SWAP_AXES ? ty : tx;
        my = SWAP_AXES ? tx : ty;
    } else {
        // Raw ADC values -> map to screen
        if (SWAP_AXES) {
            mx = fmap_clamped(ty, RAW_MIN_Y, RAW_MAX_Y, 0, sw);
            my = fmap_clamped(tx, RAW_MIN_X, RAW_MAX_X, 0, sh);
        } else {
            mx = fmap_clamped(tx, RAW_MIN_X, RAW_MAX_X, 0, sw);
            my = fmap_clamped(ty, RAW_MIN_Y, RAW_MAX_Y, 0, sh);
        }
    }

    if (INVERT_X) mx = sw - mx;
    if (INVERT_Y) my = sh - my;

    // Clamp final values to valid screen range
    if (mx < 0) mx = 0;
    if (mx > sw) mx = sw;
    if (my < 0) my = 0;
    if (my > sh) my = sh;

    data->point.x = (lv_coord_t)mx;
    data->point.y = (lv_coord_t)my;

    Serial.printf("TOUCH RAW: tX=%u tY=%u | MAPPED: x=%ld y=%ld \n", tx, ty, data->point.x, data->point.y);

}

// ------------------------------------------------------------------
// Navigation Event Handler (No longer used for screen switching)
// ------------------------------------------------------------------
static void navigate_event_handler(lv_event_t *e) {
    // kept only for compatibility with generated code in case something else expects it
    (void)e;
}

// ------------------------------------------------------------------
// Custom Event Connection
// ------------------------------------------------------------------
void connect_ui_events() {
    // We intentionally remove screen-switching logic — single-screen dashboard only.
    // If you need button handlers later, add them here.
}

// ------------------------------------------------------------------
// UI Initialization Function
// ------------------------------------------------------------------
void setup_ui(void) {
    // 1. Call the initialization function generated by EEZ Studio
    ui_init(); 
    
    // 2. Connect the custom navigation/event logic (does nothing now)
    connect_ui_events();

    // 3. Load the initial screen (Home) — single-screen app
    if (objects.main) {
        lv_screen_load(objects.main);
    } else {
    }
}

// ------------------------------------------------------------------
// === NEW: dashboard update routine
// Updates EEZ Studio labels from the sensor placeholder globals
// Run this periodically (e.g. every 500ms) from loop()
// ------------------------------------------------------------------
// ------------------------------------------------------------------
// Corrected update_dashboard() - use the exact names from screens.c
// ------------------------------------------------------------------
// --- Gradient helper: green -> red ---
// min_t and max_t define the temperature range mapped to the gradient.
// If temp <= min_t -> full green, if temp >= max_t -> full red.
static lv_color_t temp_to_gradient_color(long temp, long min_t, long max_t) {
    if (max_t == min_t) max_t = min_t + 1; // guard

    // clamp and compute normalized ratio 0..1
    float ratio = (float)(temp - min_t) / (float)(max_t - min_t);
    if (ratio < 0.0f) ratio = 0.0f;
    if (ratio > 1.0f) ratio = 1.0f;

    // start = green (0,255,0), end = red (255,0,0)
    int sr = 0, sg = 255, sb = 0;
    int er = 255, eg = 0, eb = 0;

    int r = (int)roundf(sr + (er - sr) * ratio);
    int g = (int)roundf(sg + (eg - sg) * ratio);
    int b = (int)roundf(sb + (eb - sb) * ratio);

    // build 24-bit hex RGB and return lv_color_hex
    uint32_t hex = ((uint32_t)r << 16) | ((uint32_t)g << 8) | (uint32_t)b;
    return lv_color_hex(hex);
}

void handleSerialTimeSet() {
    if (!Serial.available()) return;

    String input = Serial.readStringUntil('\n');
    input.trim();

    if (!input.startsWith("SETTIME:")) return;

    // Expected format: SETTIME:YYYY-MM-DD HH:MM:SS
    String payload = input.substring(8);
    int y, M, d, h, m, s;

    if (sscanf(payload.c_str(), "%d-%d-%d %d:%d:%d", &y, &M, &d, &h, &m, &s) == 6) {
        rtc.adjust(DateTime(y, M, d, h, m, s));
        Serial.println("RTC UPDATED ✔");
    } else {
        Serial.println("INVALID FORMAT ❌");
    }
}



void update_dashboard(void) {
    char buf[64];

    // Temperature (show integer-like value)
    if (objects.termperature_value) {
        // If your sensorTemperature is a float but you want int display, cast/round here
        long temp_display = (long)round(sensorTemperature);
        lv_color_t col = temp_to_gradient_color(temp_display, 25, 35);

        lv_obj_set_style_arc_color(objects.temperature_arc, col, LV_PART_INDICATOR | LV_STATE_DEFAULT);
        //lv_arc_set_value(objects.temperature_arc, temp_display);

        snprintf(buf, sizeof(buf), "%ld", temp_display);
        lv_label_set_text(objects.termperature_value, buf);
    }

    // Humidity
    if (objects.humidity_text) {
        long hum_display = (long)round(sensorHumidity);
        snprintf(buf, sizeof(buf), "%ld", hum_display);
        lv_label_set_text(objects.humidity_text, buf);
    }

    // Air quality numeric
    if (objects.air_quality_number_text) {
        snprintf(buf, sizeof(buf), "%d", airQualityRaw);
        lv_label_set_text(objects.air_quality_number_text, buf);
    }

    // LDR / Light
    if (objects.light_text) {
        snprintf(buf, sizeof(buf), "%d", ldrReading);
        lv_label_set_text(objects.light_text, buf);
    }
    
    if (objects.time_hour_text_1){
        snprintf(buf, sizeof(buf), "%02d", hour);
        lv_label_set_text(objects.time_hour_text_1, buf);
    }
    if (objects.time_minute_text_1){
        snprintf(buf,  sizeof(buf),  "%02d", minute);
        lv_label_set_text(objects.time_minute_text_1, buf);
    }
    if (objects.date_2){
        snprintf(buf, sizeof(buf), "%02d", date);
        lv_label_set_text(objects.date_2, buf);
    }
    if (objects.month_1){
        snprintf(buf,sizeof(buf), "%s", (month>=1 && month<=12) ? month_names[month-1] : "N/A");
        lv_label_set_text(objects.month_1, buf);
    }
    if (objects.date_3){
        const char *dow_names[] = {"Sun","Mon","Tue","Wed","Thu","Fri","Sat"};
        snprintf(buf, sizeof(buf), "%s", (dow >= 0 && dow <= 6) ? dow_names[dow] : "N/A");
        lv_label_set_text(objects.date_3, buf);
    }
}
// --- Arduino Core Functions ---

void setup() {
    // 1. Start Serial communication
    Serial.begin(115200);
    pinMode(buzzerPin, OUTPUT);

        // initialize relays
    pinMode(RELAY_LIGHT_PIN, OUTPUT);
    pinMode(RELAY_FAN_PIN, OUTPUT);
    // default OFF
    if (RELAY_ACTIVE_LOW) {
    digitalWrite(RELAY_LIGHT_PIN, HIGH);
    digitalWrite(RELAY_FAN_PIN, HIGH);
    } else {
    digitalWrite(RELAY_LIGHT_PIN, LOW);
    digitalWrite(RELAY_FAN_PIN, LOW);
    }


    // *** CRITICAL BOOT CHECK ***
    
    // --- CRITICAL STEP: HARDWARE INIT ---
    // 1. Initialize TFT_eSPI and set orientation
    tft.init(); 
   
    tft.setRotation(1); // Set to the orientation that matches your display/project (320x240)
    tft.fillScreen(TFT_BLACK); // Clear screen to black (optional, for visual confirmation)
    tft.setSwapBytes(true);

    dht.begin();
    int r = analogRead(MQ_PIN);
    mq_ema = (float)r;

      Wire.begin(25, 26); // SDA, SCL (change if you use other pins)
    if (!rtc.begin()) {
        Serial.println("ERROR: Couldn't find DS3231.");
        // handle error or continue (UI still runs)
    } else {
        Serial.println("DS3231 found.");
    }

    // 2. Initialize LVGL core
    lv_init();

    // --- Use Internal RAM (SRAM) for buffer ---
    buf_1 = (lv_color_t*)malloc(DISP_BUF_SIZE * sizeof(lv_color_t));
    if (!buf_1) {
        while (1) delay(100); // Halt execution if memory allocation fails
    } else {
    }


    // 3. Initialize display driver (v9 API)
    disp = lv_display_create(tft.width(), tft.height());
    lv_display_set_buffers(disp, buf_1, NULL, DISP_BUF_SIZE, LV_DISPLAY_RENDER_MODE_PARTIAL);
    lv_display_set_flush_cb(disp, disp_flush);

    // 4. Initialize input device driver (touch) (v9 API)
    lv_indev_t *indev_touch = lv_indev_create();
    lv_indev_set_type(indev_touch, LV_INDEV_TYPE_POINTER);
    lv_indev_set_read_cb(indev_touch, touch_read);

    // 5. Setup the User Interface (the generated screens)
    setup_ui();

    // Optional: initialize the sensor placeholder defaults (if you like)
    sensorTemperature = 40;
    sensorHumidity = 85;
    airQualityRaw = 1000;
    ldrReading = 450;
    //dateStr[0] = '\0';
    //dayOfWeekStr[0] = '\0';
}

// Simple timing for dashboard refresh
static unsigned long lastDashboardMs = 0;
const unsigned long DASH_UPDATE_INTERVAL_MS = 500;

static inline int mq_raw_to_scale(int raw) {
  if (raw <= MQ_RAW_MIN) return 0;
  if (raw >= MQ_RAW_MAX) return 1000;
  long mapped = (long)(raw - MQ_RAW_MIN) * 1000L / (MQ_RAW_MAX - MQ_RAW_MIN);
  if (mapped < 0) mapped = 0;
  if (mapped > 1000) mapped = 1000;
  return (int)mapped;
}

// ----- helper to convert raw LDR to 0..100% -----
static inline int convertLDRtoPercent(int raw) {
  if (raw <= LDR_MIN) return 0;
  if (raw >= LDR_MAX) return 100;
  // map and clamp
  int p = map(raw, LDR_MIN, LDR_MAX, 0, 100);
  if (p < 0) p = 0;
  if (p > 100) p = 100;
  return p;
}

void rtc_poll_nonblocking() {

  DateTime dt = rtc.now();

  // hour, minute, date (day of month), month, dayOfWeek
    hour = dt.hour();        // 0..23
  minute = dt.minute();    // 0..59
  date = dt.day();         // 1..31
  month = dt.month();      // 1..12
  dow  = dt.dayOfTheWeek(); // 0 = Sunday ... 6 = Saturday (RTClib)

  // Update EEZ flow variables (vars.h provides these)
  set_var_time_hour((int32_t)hour);
  set_var_time_minute((int32_t)minute);
  set_var_date((int32_t)date);

  // set month string (EEZ set_var_month expects const char*)
  if (month >= 1 && month <= 12) {
    set_var_month(month_names[month - 1]);
  } else {
    set_var_month("N/A");
  }

  // Map RTClib dayOfWeek (0=Sun..6=Sat) to your DayOfWeek enum
  // vars.h enum: DayOfWeek_SUN = 0 ... DayOfWeek_SAT = 6
  DayOfWeek dd = (DayOfWeek)dow;
  set_var_dayof_week_var(dd);

  // Optional: print for debugging
  Serial.printf("RTC: %02d:%02d  %02d/%02d  DOW=%d\n", hour, minute, date, month, dow);
}

// ----- sensor read routine (call every 5s) -----
void read_sensors_tick() {
  // Read humidity and temperature from DHT (may block for a few ms)
  float t = dht.readTemperature(); // Celsius
  float h = dht.readHumidity();

  // If read failed, keep old values (avoid writing NaN into UI)
  if (!isnan(t)) {
    sensorTemperature = t;                          // keep float used by your update_dashboard()
    // round and set EEZ integer var (function from vars.h)
    set_var_temperture_value((int32_t)lround(t));
  } else {
    // optional: log
    Serial.println("DHT readTemperature failed.");
  }

  if (!isnan(h)) {
    sensorHumidity = h;
    set_var_humidity_value((int32_t)lround(h));
  } else {
    Serial.println("DHT readHumidity failed.");
  }

  // Read LDR raw value and convert to percent
  int raw = analogRead(LDR_PIN);
  int percent = convertLDRtoPercent(raw);

  // update placeholders and EEZ var
  ldrReading = percent;                 // used by update_dashboard() -> objects.light_text
  set_var_ldr_value((int32_t)percent);

  int rawMQ = analogRead(MQ_PIN);         // raw ADC
  float raw_f = (float)rawMQ;

  #if MQ_SMOOTHING_ENABLED
  if (mq_ema < 0.0f) mq_ema = raw_f;    // seed if uninitialized
  mq_ema = MQ_ALPHA * raw_f + (1.0f - MQ_ALPHA) * mq_ema;
  int raw_used = (int)lround(mq_ema);
  #else
  int raw_used = raw;
  #endif

  // Map to 0..1000 (same style you used earlier)
  int scaled = mq_raw_to_scale(raw_used);

  // Update placeholders and EEZ vars
  airQualityRaw = scaled;                  // used by your update_dashboard()
  set_var_air_quality_value((int32_t)scaled);

  // Derive status string (tune thresholds as needed)
  const char *status = "N/A";
  if (scaled >= 0) {
    if (scaled > 800) status = "Toxic";
    else if (scaled > 600) status = "Poor";
    else if (scaled > 300) status = "Good";
    else status = "Fine";
  }
  set_var_air_quality_status(status);      // update EEZ Studio string var
  // optional: update label too if you want immediate UI change
  if (objects.air_quality_status_text) {
      lv_label_set_text(objects.air_quality_status_text, status);
  }
    Serial.printf("SENSORS: T=%.1fC H=%.1f%% LDR_raw=%d LDR%%=%d\n", t, h, raw, percent);
  Serial.printf("MQ135: raw=%d raw_used=%d scaled=%d status=%s\n", raw, raw_used, scaled, status);

}


void loop() {
    // 1. Tell LVGL how much time has passed (best practice is lv_tick_inc(1) for 1ms)
    lv_tick_inc(1); 
    
    // 2. Let LVGL perform its tasks (drawing, event handling)
    lv_task_handler();

    // 3. Periodically update the dashboard widgets (from sensor placeholder globals)
    unsigned long now = millis();
    if (now - lastDashboardMs >= DASH_UPDATE_INTERVAL_MS) {
        lastDashboardMs = now;
        update_dashboard();
    }
    if (millis() - lastSensorMs >= Sensor_Read_Interval) {
        lastSensorMs = millis();
        read_sensors_tick();
        rtc_poll_nonblocking();
    }
    handleSerialTimeSet();
    delay(1); // Allow other tasks/interrupts to run
}
