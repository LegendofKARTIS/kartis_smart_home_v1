#include <Arduino.h>


// --- HARDWARE DRIVER INTEGRATION (TFT_eSPI Example) ---
#include <TFT_eSPI.h> 
#include <lvgl.h>

// Include necessary headers for heap allocation
#include "esp_heap_caps.h" 

// Create a TFF_eSPI object. The configuration must be done in the
// User_Setup.h file inside the TFT_eSPI library folder.
TFT_eSPI tft = TFT_eSPI();

// Calibration constants (fixed — no rotation)
const uint16_t RAW_MIN_X = 429;
const uint16_t RAW_MAX_X = 3593;
const uint16_t RAW_MIN_Y = 1905;
const uint16_t RAW_MAX_Y = 3345;

// Settings for your hardware (you said no rotation)
const bool SWAP_AXES = false;
const bool INVERT_X  = false;
const bool INVERT_Y  = true;

// --- EEZ STUDIO GENERATED FILES INCLUSION ---
// Assuming these files are available in the project structure
#include "ui.h"
#include "screens.h" // Contains the 'objects_t' struct and 'extern objects_t objects;'
#include "vars.h"   // <- declares get_var_* / set_var_* functions generated by EEZ Studio

// --- Configuration Constants (FIXED RESOLUTION FOR COMPILE TIME) ---
#define LV_HOR_RES_MAX 320 
#define LV_VER_RES_MAX 240 
// Buffer size remains 1/5th.
#define DISP_BUF_SIZE (LV_HOR_RES_MAX * LV_VER_RES_MAX / 5) 

// --- LVGL Display and Input Variables ---
lv_color_t *buf_1; 
lv_display_t *disp;

// Flag to manually control color swapping
#define FORCE_COLOR_SWAP 1 

// ------------------------------------------------------------------
// === NEW: Sensor placeholder globals (fill these from your sensor code)
// ------------------------------------------------------------------
// DO NOT rename these — update them in your sensor routines (DHT, MQ135, LDR, RTC)
float sensorTemperature = 32;             // Celsius (e.g. 25.3)
float sensorHumidity    = 85;             // Percent (e.g. 53.4)
int   airQualityRaw     = 600;              // Raw MQ135 reading or AQI-like int
String airQualityStatusStr = "Good";   // "Good", "Super", "Poor", "Toxic", etc.
int   ldrReading        = 44;              // Raw LDR ADC value (or computed lux)
//char  dateStr[32]      = "";               // human-readable date (e.g. "2025-11-30")
//char  dayOfWeekStr[16] = "";               // e.g. "Sun", "Monday"
// Forward prototype so setup() can reference it even if function is below
void disp_flush(lv_display_t *display, const lv_area_t *area, unsigned char *data);

// ------------------------------------------------------------------
// Small inline mapper (safe vs inverted raw ranges)
// ------------------------------------------------------------------
static inline int32_t fmap_clamped(int32_t val, int32_t in_min, int32_t in_max,
                                   int32_t out_min, int32_t out_max) {
    if (in_max == in_min) return out_min;
    if (in_min < in_max) {
        long mapped = (long)(val - in_min) * (out_max - out_min) / (long)(in_max - in_min) + out_min;
        if (mapped < out_min) return out_min;
        if (mapped > out_max) return out_max;
        return (int32_t)mapped;
    } else {
        long mapped = (long)(in_min - val) * (out_max - out_min) / (long)(in_min - in_max) + out_min;
        if (mapped < out_min) return out_min;
        if (mapped > out_max) return out_max;
        return (int32_t)mapped;
    }
}


// --- 2. Input Read Callback (Reads touch input from the physical screen) ---

/**
 * @brief Reads touch input and reports the state (pressed/released) and coordinates to LVGL.
 */

void touch_read(lv_indev_t *indev_driver, lv_indev_data_t *data) {
    uint16_t tx = 0, ty = 0;
    bool pressed = tft.getTouch(&tx, &ty);

    const uint16_t sw = tft.width();   // 320
    const uint16_t sh = tft.height();  // 240

    if (!pressed) {
        data->state = LV_INDEV_STATE_RELEASED;
        return;
    }

    data->state = LV_INDEV_STATE_PRESSED;

    // Detect whether library already scales coordinates (0..screen)
    bool scaled = (tx <= sw && ty <= sh);

    int32_t mx, my;

    if (scaled) {
        // Already in screen coords — apply swap/invert if needed
        mx = SWAP_AXES ? ty : tx;
        my = SWAP_AXES ? tx : ty;
    } else {
        // Raw ADC values -> map to screen
        if (SWAP_AXES) {
            mx = fmap_clamped(ty, RAW_MIN_Y, RAW_MAX_Y, 0, sw);
            my = fmap_clamped(tx, RAW_MIN_X, RAW_MAX_X, 0, sh);
        } else {
            mx = fmap_clamped(tx, RAW_MIN_X, RAW_MAX_X, 0, sw);
            my = fmap_clamped(ty, RAW_MIN_Y, RAW_MAX_Y, 0, sh);
        }
    }

    if (INVERT_X) mx = sw - mx;
    if (INVERT_Y) my = sh - my;

    // Clamp final values to valid screen range
    if (mx < 0) mx = 0;
    if (mx > sw) mx = sw;
    if (my < 0) my = 0;
    if (my > sh) my = sh;

    data->point.x = (lv_coord_t)mx;
    data->point.y = (lv_coord_t)my;

    Serial.printf("TOUCH RAW: tX=%u tY=%u | MAPPED: x=%ld y=%ld \n", tx, ty, data->point.x, data->point.y);
}

// ------------------------------------------------------------------
// Navigation Event Handler (No longer used for screen switching)
// ------------------------------------------------------------------
static void navigate_event_handler(lv_event_t *e) {
    // kept only for compatibility with generated code in case something else expects it
    (void)e;
}

// ------------------------------------------------------------------
// Custom Event Connection
// ------------------------------------------------------------------
void connect_ui_events() {
    // We intentionally remove screen-switching logic — single-screen dashboard only.
    // If you need button handlers later, add them here.
}

// ------------------------------------------------------------------
// UI Initialization Function
// ------------------------------------------------------------------
void setup_ui(void) {
    // 1. Call the initialization function generated by EEZ Studio
    ui_init(); 
    
    // 2. Connect the custom navigation/event logic (does nothing now)
    connect_ui_events();

    // 3. Load the initial screen (Home) — single-screen app
    if (objects.main) {
        lv_screen_load(objects.main);
    } else {
    }
}

// ------------------------------------------------------------------
// === NEW: dashboard update routine
// Updates EEZ Studio labels from the sensor placeholder globals
// Run this periodically (e.g. every 500ms) from loop()
// ------------------------------------------------------------------
// ------------------------------------------------------------------
// Corrected update_dashboard() - use the exact names from screens.c
// ------------------------------------------------------------------
void update_dashboard(void) {
    char buf[64];

    // Temperature (show integer-like value)
    if (objects.termperature_value) {
        // If your sensorTemperature is a float but you want int display, cast/round here
        long temp_display = (long)round(sensorTemperature);
        snprintf(buf, sizeof(buf), "%ld", temp_display);
        lv_label_set_text(objects.termperature_value, buf);
    }

    // Humidity
    if (objects.humidity_text) {
        long hum_display = (long)round(sensorHumidity);
        snprintf(buf, sizeof(buf), "%ld", hum_display);
        lv_label_set_text(objects.humidity_text, buf);
    }

    // Air quality numeric
    if (objects.air_quality_number_text) {
        snprintf(buf, sizeof(buf), "%d", airQualityRaw);
        lv_label_set_text(objects.air_quality_number_text, buf);
    }

    // Air quality status (derive from numeric and update label and EEZ var)
    if (objects.air_quality_status_text) {
        const char *status = "N/A";
        if (airQualityRaw >= 0) {
            if (airQualityRaw > 800) status = "Toxic";
            else if (airQualityRaw > 600) status = "Poor";
            else if (airQualityRaw > 300) status = "Moderate";
            else status = "Good";
        }
        lv_label_set_text(objects.air_quality_status_text, status);
        // Also update the EEZ variable so flow logic can use it:
        set_var_air_quality_status(status);
    }

    // LDR / Light
    if (objects.light_text) {
        snprintf(buf, sizeof(buf), "%d", ldrReading);
        lv_label_set_text(objects.light_text, buf);
    }
}


// --- Arduino Core Functions ---

void setup() {
    // 1. Start Serial communication
    Serial.begin(115200);

    // *** CRITICAL BOOT CHECK ***
    
    // --- CRITICAL STEP: HARDWARE INIT ---
    // 1. Initialize TFT_eSPI and set orientation
    tft.init(); 

    
    
    tft.setRotation(1); // Set to the orientation that matches your display/project (320x240)
    tft.fillScreen(TFT_BLACK); // Clear screen to black (optional, for visual confirmation)
    tft.setSwapBytes(true);

    

    // 2. Initialize LVGL core
    lv_init();

    // --- Use Internal RAM (SRAM) for buffer ---
    buf_1 = (lv_color_t*)malloc(DISP_BUF_SIZE * sizeof(lv_color_t));
    if (!buf_1) {
        while (1) delay(100); // Halt execution if memory allocation fails
    } else {
    }


    // 3. Initialize display driver (v9 API)
    disp = lv_display_create(tft.width(), tft.height());
    lv_display_set_buffers(disp, buf_1, NULL, DISP_BUF_SIZE, LV_DISPLAY_RENDER_MODE_PARTIAL);
    lv_display_set_flush_cb(disp, disp_flush);

    // 4. Initialize input device driver (touch) (v9 API)
    lv_indev_t *indev_touch = lv_indev_create();
    lv_indev_set_type(indev_touch, LV_INDEV_TYPE_POINTER);
    lv_indev_set_read_cb(indev_touch, touch_read);

    // 5. Setup the User Interface (the generated screens)
    setup_ui();

    // Optional: initialize the sensor placeholder defaults (if you like)
    sensorTemperature = 40;
    sensorHumidity = 85;
    airQualityRaw = 800;
    airQualityStatusStr = "N/A";
    ldrReading = 450;
    //dateStr[0] = '\0';
    //dayOfWeekStr[0] = '\0';
}

// Simple timing for dashboard refresh
static unsigned long lastDashboardMs = 0;
const unsigned long DASH_UPDATE_INTERVAL_MS = 500;

void loop() {
    // 1. Tell LVGL how much time has passed (best practice is lv_tick_inc(1) for 1ms)
    lv_tick_inc(1); 

    // 2. Let LVGL perform its tasks (drawing, event handling)
    lv_task_handler();

    // 3. Periodically update the dashboard widgets (from sensor placeholder globals)
    unsigned long now = millis();
    if (now - lastDashboardMs >= DASH_UPDATE_INTERVAL_MS) {
        lastDashboardMs = now;
        update_dashboard();
    }

    delay(1); // Allow other tasks/interrupts to run
}
